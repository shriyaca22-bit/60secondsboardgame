<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Flashcard Words (60s)</title>
    <style>
      :root {
        --bg: #0b1220;
        --card: #121b2e;
        --card-2: #0f172a;
        --text: #e6eaf2;
        --muted: #aab4c5;
        --accent: #6ee7b7;
        --danger: #fb7185;
        --border: rgba(255, 255, 255, 0.10);
        --shadow: 0 20px 60px rgba(0, 0, 0, 0.45);
        --radius: 18px;
      }

      * { box-sizing: border-box; }
      body {
        margin: 0;
        font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
        background: radial-gradient(1200px 800px at 50% 20%, rgba(110,231,183,0.14), transparent 55%),
                    radial-gradient(900px 700px at 80% 70%, rgba(59,130,246,0.12), transparent 55%),
                    var(--bg);
        color: var(--text);
        min-height: 100vh;
        display: flex;
        flex-direction: column;
      }

      header {
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 18px 16px 8px;
      }

      .timer {
        display: inline-flex;
        align-items: center;
        gap: 10px;
        padding: 10px 14px;
        border: 1px solid var(--border);
        border-radius: 999px;
        background: rgba(255,255,255,0.04);
        backdrop-filter: blur(8px);
      }

      .timer .dot {
        width: 10px;
        height: 10px;
        border-radius: 999px;
        background: var(--muted);
      }

      .timer.running .dot { background: var(--accent); }
      .timer.ended .dot { background: var(--danger); }

      .timer strong {
        font-size: 14px;
        letter-spacing: 0.2px;
      }

      main {
        flex: 1;
        display: grid;
        grid-template-columns: 1fr minmax(320px, 520px) 1fr;
        align-items: center;
        padding: 16px;
        gap: 16px;
      }

      .side {
        justify-self: end;
        width: min(320px, 100%);
        display: flex;
        flex-direction: column;
        gap: 12px;
      }

      .sideCard {
        border: 1px solid var(--border);
        border-radius: var(--radius);
        background: rgba(255,255,255,0.03);
        box-shadow: var(--shadow);
        padding: 14px;
      }

      .sideCard h3 {
        margin: 0 0 10px;
        font-size: 14px;
        color: var(--muted);
        font-weight: 600;
      }

      .prevWords {
        min-height: 72px;
        padding: 10px;
        border-radius: 12px;
        background: rgba(0,0,0,0.18);
        border: 1px solid rgba(255,255,255,0.08);
        color: var(--text);
        font-size: 14px;
        line-height: 1.4;
      }

      .prevWords.empty {
        color: rgba(230,234,242,0.55);
        font-style: italic;
      }

      .center {
        justify-self: center;
        width: 100%;
      }

      .card {
        width: 100%;
        aspect-ratio: 3 / 4;
        border-radius: 22px;
        background: linear-gradient(180deg, rgba(255,255,255,0.04), rgba(255,255,255,0.02));
        border: 1px solid var(--border);
        box-shadow: var(--shadow);
        position: relative;
        overflow: hidden;
        display: grid;
        place-items: center;
        padding: 18px;
      }

      .card::before {
        content: "";
        position: absolute;
        inset: -40%;
        background: conic-gradient(from 120deg, rgba(110,231,183,0.22), rgba(59,130,246,0.18), rgba(251,113,133,0.16), rgba(110,231,183,0.22));
        filter: blur(26px);
        opacity: 0.55;
      }

      .cardInner {
        position: relative;
        z-index: 1;
        width: 100%;
        height: 100%;
        border-radius: 18px;
        background: rgba(15, 23, 42, 0.55);
        border: 1px solid rgba(255,255,255,0.10);
        display: grid;
        place-items: center;
        padding: 16px;
      }

      .words {
        width: 100%;
        height: 100%;
        display: none; /* shown only while active */
        grid-template-columns: 1fr;
        grid-auto-rows: min-content;
        gap: 10px;
        align-content: center;
        justify-items: center;
        text-align: center;
        padding: 8px 6px;
      }

      .words.active { display: grid; }

      .word {
        padding: 10px 14px;
        border-radius: 999px;
        border: 1px solid rgba(255,255,255,0.12);
        background: rgba(255,255,255,0.04);
        font-size: 18px;
        font-weight: 700;
        letter-spacing: 0.2px;
        width: min(92%, 360px);
      }

      .idle {
        display: grid;
        place-items: center;
        gap: 12px;
        text-align: center;
      }

      .idle p {
        margin: 0;
        color: rgba(230,234,242,0.70);
        font-size: 14px;
      }

      button {
        border: 1px solid rgba(255,255,255,0.14);
        background: rgba(255,255,255,0.06);
        color: var(--text);
        border-radius: 14px;
        padding: 11px 14px;
        cursor: pointer;
        font-weight: 650;
        font-size: 14px;
        transition: transform 0.06s ease, background 0.2s ease, border-color 0.2s ease;
        user-select: none;
      }
      button:hover {
        background: rgba(255,255,255,0.10);
        border-color: rgba(255,255,255,0.22);
      }
      button:active { transform: translateY(1px); }
      button:disabled {
        cursor: not-allowed;
        opacity: 0.55;
      }

      .playBtn {
        display: inline-flex;
        align-items: center;
        gap: 10px;
        padding: 12px 16px;
        border-radius: 16px;
        border: 1px solid rgba(110,231,183,0.35);
        background: rgba(110,231,183,0.10);
      }

      .playIcon {
        width: 0;
        height: 0;
        border-left: 12px solid var(--accent);
        border-top: 8px solid transparent;
        border-bottom: 8px solid transparent;
        filter: drop-shadow(0 6px 12px rgba(110,231,183,0.25));
      }

      .hint {
        margin-top: 6px;
        font-size: 12px;
        color: rgba(230,234,242,0.55);
      }

      @media (max-width: 980px) {
        main {
          grid-template-columns: 1fr;
          grid-template-rows: auto auto;
        }
        .side { justify-self: center; order: 2; }
        .center { order: 1; }
      }
    </style>
  </head>
  <body>
    <header>
      <div id="timerPill" class="timer">
        <span class="dot" aria-hidden="true"></span>
        <strong>Time: <span id="timeLeft">60</span>s</strong>
      </div>
    </header>

    <main>
      <div></div>

      <div class="center">
        <div class="card" role="region" aria-label="Flashcard">
          <div class="cardInner">
            <div id="idleView" class="idle">
              <button id="playBtn" class="playBtn" type="button" aria-label="Play">
                <span class="playIcon" aria-hidden="true"></span>
                Play
              </button>
              <p>Click play to reveal 12 words for 60 seconds.</p>
              <div class="hint">After time ends, the card clears automatically.</div>
            </div>

            <div id="wordsGrid" class="words" aria-live="polite"></div>
          </div>
        </div>
      </div>

      <aside class="side">
        <button id="togglePrevBtn" type="button" disabled>
          Show previous card
        </button>

        <div id="prevPanel" class="sideCard" style="display:none;">
          <h3>Previous card</h3>
          <div id="prevWords" class="prevWords empty">No previous card yet.</div>
        </div>

        <div class="sideCard">
          <h3>How words are chosen</h3>
          <div style="color: rgba(230,234,242,0.75); font-size: 13px; line-height: 1.45;">
            Words are <b>shuffled once</b> into a “deck” and dealt in groups of <b>7</b> each round.
            When the deck runs out, it reshuffles automatically.
          </div>
        </div>
      </aside>
    </main>

    <script>
      /***********************
       * 1) PUT YOUR WORDS HERE
       ***********************/
      async function loadWords() {
      const response = await fetch("words.txt");
      const text = await response.text();
    
      WORDS_DB = text
        .split("\n")
        .map(w => w.trim())
        .filter(w => w.length > 0);
    
      if (WORDS_DB.length < WORDS_PER_CARD) {
        alert("Please add at least 12 words to words.txt");
      }
    
      buildDeck();
    }


      const WORDS_PER_CARD = 12;
      const ROUND_SECONDS = 60;

      // DOM
      const playBtn = document.getElementById("playBtn");
      const idleView = document.getElementById("idleView");
      const wordsGrid = document.getElementById("wordsGrid");
      const timeLeftEl = document.getElementById("timeLeft");
      const timerPill = document.getElementById("timerPill");

      const togglePrevBtn = document.getElementById("togglePrevBtn");
      const prevPanel = document.getElementById("prevPanel");
      const prevWordsEl = document.getElementById("prevWords");

      // State
      let deck = [];
      let deckIndex = 0;

      let isRunning = false;
      let remaining = ROUND_SECONDS;
      let intervalId = null;

      let lastCardWords = null;   // array of 7 words
      let prevVisible = false;

      function shuffle(array) {
        // Fisher-Yates
        for (let i = array.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [array[i], array[j]] = [array[j], array[i]];
        }
        return array;
      }

      function buildDeck() {
        deck = shuffle([...WORDS_DB]);
        deckIndex = 0;
      }

      function nextCardWords() {
        // Ensure we have a deck
        if (deck.length === 0) buildDeck();

        // If not enough words left for a full card, reshuffle
        if (deckIndex + WORDS_PER_CARD > deck.length) {
          buildDeck();
        }

        const card = deck.slice(deckIndex, deckIndex + WORDS_PER_CARD);
        deckIndex += WORDS_PER_CARD;
        return card;
      }

      function renderWords(words) {
        wordsGrid.innerHTML = "";
        for (const w of words) {
          const div = document.createElement("div");
          div.className = "word";
          div.textContent = w;
          wordsGrid.appendChild(div);
        }
      }

      function setTimerPillState(state) {
        timerPill.classList.remove("running", "ended");
        if (state === "running") timerPill.classList.add("running");
        if (state === "ended") timerPill.classList.add("ended");
      }

      function setTime(value) {
        remaining = value;
        timeLeftEl.textContent = String(remaining);
      }

      function showIdle() {
        wordsGrid.classList.remove("active");
        idleView.style.display = "grid";
        playBtn.disabled = false;
        isRunning = false;
        setTimerPillState("ended");
        setTime(ROUND_SECONDS);
      }

      function showActive(words) {
        idleView.style.display = "none";
        wordsGrid.classList.add("active");
        renderWords(words);
        playBtn.disabled = true;
        isRunning = true;
        setTimerPillState("running");
      }

      function stopTimer() {
        if (intervalId !== null) {
          clearInterval(intervalId);
          intervalId = null;
        }
      }

      function endRound() {
        stopTimer();
        // Clear words and go back to blank + play
        showIdle();

        // Enable previous toggle once we have a last card
        togglePrevBtn.disabled = !lastCardWords;
        if (lastCardWords && prevVisible) {
          // Keep prev panel visible if user chose it
          updatePrevPanel();
        }
      }

      function startRound() {
        if (isRunning) return;

        const words = nextCardWords();
        lastCardWords = words;

        // Previous button becomes available once there is a previous card,
        // but we allow it immediately so they can see it even during the round.
        togglePrevBtn.disabled = false;

        showActive(words);
        setTime(ROUND_SECONDS);
        stopTimer();

        intervalId = setInterval(() => {
          remaining -= 1;
          timeLeftEl.textContent = String(remaining);

          if (remaining <= 0) {
            endRound();
          }
        }, 1000);
      }

      function updatePrevPanel() {
        if (!prevVisible) {
          prevPanel.style.display = "none";
          togglePrevBtn.textContent = "Show previous card";
          return;
        }

        prevPanel.style.display = "block";
        togglePrevBtn.textContent = "Hide previous card";

        if (!lastCardWords) {
          prevWordsEl.textContent = "No previous card yet.";
          prevWordsEl.classList.add("empty");
          return;
        }

        prevWordsEl.classList.remove("empty");
        prevWordsEl.textContent = lastCardWords.join(" • ");
      }

      // Events
      playBtn.addEventListener("click", () => {
        startRound();
      });

      togglePrevBtn.addEventListener("click", () => {
        prevVisible = !prevVisible;
        updatePrevPanel();
      });

      // Init
      (async function init() {
        await loadWords();
        showIdle();
        updatePrevPanel();
      })();
    </script>
  </body>
</html>

